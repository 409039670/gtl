#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <math.h>
#include <string>
#include <vector>
#include <limits>
#include <memory.h>
#include <list>
#include <algorithm>
#include <functional>
#include <vector>
#include <cstdlib>			// standard C++ includes
#include <cctype>
#include <iostream>
#include <typeinfo>
#include <tuple>
#include <array>
#include <iosfwd>
#include <ios>
#include <istream>
#include <ostream>
#include <fstream>
#include <sstream>
#include <assert.h>
#include <time.h>
     
#include <cstddef>   // ptrdiff_t
#include <cmath>
#include <cstring>
#include "../../../gtl/rstartree.h"
#include "../../../gtl/xlist.h"
#include "../../../gtl/timer.h"
#include "../../../gtl/spatiotemporalreader.h"
#include "../../../gtl/console.h"
#include "../../../gtl/envelopes.h"
#include "../../../gtl/rtree.h"


typedef gtl::Xlist<uint64_t,double,4,32> XLIST;
typedef gtl::RStarTree<uint64_t,4,16,32> RSTARTREE;
typedef gtl::RTree<uint64_t,double,4,double,32,16> RTREE;
typedef gtl::Envelope<double,4> ENVELOPE;
std::string _base = "D:\\GTL\\data\\";
gtl::Envelope<double,4> _cubeenvelope;
int _cube_size_length ;

gtl::Console<char> _console ;
/* import a dataset generated by Brinkhoff spatiotemporal generator
		A line of the text file represents the generated position of an object; 
		it is described by the following fields (separated by tabulators):
			• newpoint (for the first position of a new moving object), 
				point (for the following positions of a moving object), 
				or disappearpoint (if a moving object has reached its destination)
			• the id of the point
			• the sequence number (starts with 1)
			• the id of the object class
			• the time stamp (as integer)
			• the x-coordinate (as floating-point number)
			• the y-coordinate (as floating-point number)
			• the current speed (in space units per time unit as a floating-point number; 
				note: the speed may change several times between two reported positions)
			• the x-coordinate of the next node that will be passed (as integer)
			• the y-coordinate of the next node that will be passed (as integer)
*/
struct BrinkhoffItem{
	char  status[255];
	uint64_t point_id;
	uint64_t sequence_number;
	uint64_t object_class_id;
	double  timestamp;
	double  x,y,z;
	double  current_speed;
	double  nx,ny,nz;
};


void readBrinkhoffItem(std::ifstream & ifs,BrinkhoffItem & bf)
{		
	char sz[1024];
	if(!ifs.eof()){
		//newpoint, point or disappearpoint
		ifs.getline(sz,1024,'	');	
		memcpy(bf.status,sz,255);
		// id of the point
		ifs.getline(sz,1024,'	'); 
		bf.point_id = gtl::stringToNumber<uint64_t,char>(sz);
		// the sequence number
		ifs.getline(sz,1024,'	');
		bf.sequence_number = gtl::stringToNumber<uint64_t,char>(sz);
		//the id of the object class
		ifs.getline(sz,1024,'	');
		bf.object_class_id = gtl::stringToNumber<uint64_t,char>(sz);
		//the time stamp (as integer)
		ifs.getline(sz,1024,'	');
		bf.timestamp = gtl::stringToNumber<int32_t,char>(sz);
		//the x-coordinate (as floating-point number)
		ifs.getline(sz,1024,'	');
		bf.x = gtl::stringToNumber<double,char>(sz);
		//the y-coordinate (as floating-point number)
		ifs.getline(sz,1024,'	');
		bf.y = gtl::stringToNumber<double,char>(sz);
		//the current speed (in space units per time unit as a floating-point number; 
		ifs.getline(sz,1024,'	');
		bf.current_speed = gtl::stringToNumber<double,char>(sz);
		//the x-coordinate of the next node that will be passed (as integer)
		ifs.getline(sz,1024,'	');
		bf.nx = gtl::stringToNumber<double,char>(sz);
		// the y-coordinate of the next node that will be passed (as integer)
		ifs.getline(sz,1024);
		bf.ny = gtl::stringToNumber<double,char>(sz);

		// calculate the velocity and x,y,z values
		bf.z = rand()%100;
		bf.nz = rand()%100;				
	}

}


uint32_t loadDataset(std::string & input_file, const uint32_t maxcount,BrinkhoffItem ** bfis)
{
	try
	{		
		*bfis = new BrinkhoffItem[maxcount];
		std::locale _loc = std::locale::global(std::locale("")); 
		std::ifstream ifs;
		ifs.open(input_file.c_str(),std::ios_base::in|std::ios_base::_Nocreate);
		BrinkhoffItem * bfi = *bfis ;
		uint32_t j=0;
		while (!ifs.eof())
		{
			readBrinkhoffItem(ifs,*bfi);
			j++;
			bfi++;
			if(j==maxcount)
				break;
		}
		ifs.close();
		std::locale::global(_loc);
		return j;
	}
	catch (...)
	{
		if(*bfis) delete [] (*bfis);
		std::cerr << "******ERROR******" << std::endl;
		return 0;
	}
}

//create XList database 
void insertDataset(std::string & data_file, const uint32_t maxcount, std::ofstream & time_record_file )
{
	XLIST xlist;
	RSTARTREE rtree;
	BrinkhoffItem * bfis=0;
	uint32_t realcount = loadDataset(data_file,maxcount,&bfis);
	uint64_t id =0;
	gtl::Timer<char> t1;
	std::string sz =" XList insertion time "+ gtl::numberToString<char,uint32_t>(maxcount);
	t1.start(sz.c_str());
	for(uint32_t i=0;i<realcount;++i)
	{
		id= bfis[i].point_id;
		id=id<<32;
		id+=bfis[i].sequence_number;

		ENVELOPE e(bfis[i].timestamp,bfis[i].x,bfis[i].y,bfis[i].z,5);
		xlist.insert(id,e);
	}
	t1.end();
	sz =" RTree insertion time "+ gtl::numberToString<char,uint32_t>(maxcount);
	t1.start(sz.c_str());
	for(uint32_t i=0;i<realcount;++i)
	{
		id = bfis[i].point_id;
		id=id<<32;
		id+=bfis[i].sequence_number;

		ENVELOPE e(bfis[i].timestamp,bfis[i].x,bfis[i].y,bfis[i].z,10);
		rtree.insert(e.getLowerBounds(),e.getUpperBounds(),id);
	}
	t1.end();

	t1.write(time_record_file);
}



void test_xlist_rstartree(const std::string& filename)
{
	unsigned long long nodenumber=0;
	unsigned long long pointnumber=0;
	unsigned int runtimes =10;

	unsigned long long identifier=0;
	unsigned long long order=0;

	size_t i,j,c,n;

	gtl::Envelope<double,4> total ;

	gtl::MovingEnvelope<double,4> me;

	gtl::Timer<char> timer;
	std::ofstream ofs(_base+"xlist"+filename+".txt");

	gtl::Envelopes<double,4> queryEnvelopes;
	int tn =500;
	int ts=10;
	std::vector<uint64_t> results;

	gtl::MovingPoints<double,4> mpnts; 
	gtl::SpatiotemporalReader<double,4>::readPoints(_base+filename+".mpf",mpnts);
	total = mpnts.getEnvelope();

	unsigned long long keycomparisons=0;
	std::vector<unsigned long long> comparisons;
	//1. setup the xlist
	{

		

		XLIST xlist;

		_console.print( "setup the xlist\n");
		timer.start(" ");
		n = mpnts.size();
		for(i=0;i<n;i++)
		{
			xlist.insert(i,mpnts[i].getEnvelope());
		} 
		timer.end();
		timer.write(ofs);
		timer.clear();

		ofs<< n <<" "<< xlist.numberNodes()<<std::endl; 

		//query times
		for(int t = ts;t<=tn;t+=10)
		{
			_console.print("%d\n",t);
			queryEnvelopes.read(_base+"envelopes"+gtl::numberToString<char,int>(t)+".ef");
			queryEnvelopes.transform(_cubeenvelope,total);

			gtl::Envelopes<double,4>::iterator it = queryEnvelopes.begin();
			keycomparisons=0;
			timer.start("\n");
			for(;it!=queryEnvelopes.end();it++)
			{
				xlist.m_stats.keycomparisons=0;
				xlist.search(*it,results);
				keycomparisons+=xlist.m_stats.keycomparisons;
				results.clear();
			}
			timer.end();
			comparisons.push_back(keycomparisons);
		}
		timer.write(ofs);
		timer.clear();
		ofs<<std::endl;
		for(auto it = comparisons.begin();it!=comparisons.end();it++)
		{
			ofs<<*it << std::endl;
		}
		comparisons.clear();
	}

	//2. setup the xlist
	{
		 

		RSTARTREE  rtree;

		_console.print( "setup the rstartree\n");
		timer.start(" ");
		n = mpnts.size();
		for(i=0;i<n;i++)
		{
			ENVELOPE e =mpnts[i].getEnvelope();
			rtree.insert(e.getLowerBounds(),e.getUpperBounds(),i);
		} 
		timer.end();
		timer.write(ofs);
		timer.clear();

		ofs<< n <<" "<<rtree.numberNodes()<<std::endl; 

		//query times
		for(int t = ts;t<=tn;t+=10)
		{
			_console.print("%d\n",t);
			queryEnvelopes.read(_base+"envelopes"+gtl::numberToString<char,int>(t)+".ef");
			queryEnvelopes.transform(_cubeenvelope,total);

			gtl::Envelopes<double,4>::iterator it = queryEnvelopes.begin();
			keycomparisons=0;
			std::vector<unsigned long long> stats;
			timer.start("\n");
			for(;it!=queryEnvelopes.end();it++)
			{
				rtree.search(it->getLowerBounds(),it->getUpperBounds(),results,stats);
				results.clear();
				keycomparisons+=stats[2];
				stats.clear();
			}
			timer.end();
			comparisons.push_back(keycomparisons);
		}
		timer.write(ofs);
		timer.clear();
		ofs<<std::endl;
		for(std::vector<unsigned long long>::iterator it = comparisons.begin();it!=comparisons.end();it++)
		{
			ofs<<*it << std::endl;
		}
		comparisons.clear();
	}
	ofs.close();
}

void test_xlist_rtree(const std::string& filename)
{
	unsigned long long nodenumber=0;
	unsigned long long pointnumber=0;
	unsigned int runtimes =10;

	unsigned long long identifier=0;
	unsigned long long order=0;

	size_t i,j,c,n;

	gtl::Envelope<double,4> total ;

	gtl::MovingEnvelope<double,4> me;

	gtl::Timer<char> timer;
	std::ofstream ofs(_base+"xlist_rtree_"+filename+".txt");

	gtl::Envelopes<double,4> queryEnvelopes;
	int tn =500;
	int ts=10;
	std::vector<uint64_t> results;

	gtl::MovingPoints<double,4> mpnts; 
	gtl::SpatiotemporalReader<double,4>::readPoints(_base+filename+".mpf",mpnts);
	total = mpnts.getEnvelope();

	unsigned long long keycomparisons=0;
	std::vector<unsigned long long> comparisons;
	//1. setup the xlist
	{

		

		XLIST xlist;

		_console.print( "setup the xlist\n");
		timer.start(" ");
		n = mpnts.size();
		for(i=0;i<n;i++)
		{
			xlist.insert(i,mpnts[i].getEnvelope());
		} 
		timer.end();
		timer.write(ofs);
		timer.clear();

		ofs<< n <<" "<< xlist.numberNodes()<<std::endl; 

		//query times
		for(int t = ts;t<=tn;t+=10)
		{
			_console.print("%d\n",t);
			queryEnvelopes.read(_base+"envelopes"+gtl::numberToString<char,int>(t)+".ef");
			queryEnvelopes.transform(_cubeenvelope,total);

			gtl::Envelopes<double,4>::iterator it = queryEnvelopes.begin();
			keycomparisons=0;
			timer.start("\n");
			for(;it!=queryEnvelopes.end();it++)
			{
				xlist.m_stats.keycomparisons=0;
				xlist.search(*it,results);
				keycomparisons+=xlist.m_stats.keycomparisons;
				results.clear();
			}
			timer.end();
			comparisons.push_back(keycomparisons);
		}
		timer.write(ofs);
		timer.clear();
		ofs<<std::endl;
		for(auto it = comparisons.begin();it!=comparisons.end();it++)
		{
			ofs<<*it << std::endl;
		}
		comparisons.clear();
	}

	//2. setup the rtree
	{
		 

		RTREE  rtree;

		_console.print( "setup the rtree\n");
		timer.start(" ");
		n = mpnts.size();
		for(i=0;i<n;i++)
		{
			ENVELOPE e =mpnts[i].getEnvelope();
			rtree.insert(e.getLowerBounds(),e.getUpperBounds(),i);
		} 
		timer.end();
		timer.write(ofs);
		timer.clear();

		ofs<< n <<" "<<rtree.numbNodes()<<std::endl; 

		//query times
		for(int t = ts;t<=tn;t+=10)
		{
			_console.print("%d\n",t);
			queryEnvelopes.read(_base+"envelopes"+gtl::numberToString<char,int>(t)+".ef");
			queryEnvelopes.transform(_cubeenvelope,total);

			gtl::Envelopes<double,4>::iterator it = queryEnvelopes.begin();
			keycomparisons=0;
			std::vector<unsigned long long> stats;
			timer.start("\n");
			for(;it!=queryEnvelopes.end();it++)
			{
				rtree.comparisonNumber=0;
				rtree.search(it->getLowerBounds(),it->getUpperBounds(),results);
				results.clear();
				keycomparisons+=rtree.comparisonNumber;
				stats.clear();
			}
			timer.end();
			comparisons.push_back(keycomparisons);
		}
		timer.write(ofs);
		timer.clear();
		ofs<<std::endl;
		for(std::vector<unsigned long long>::iterator it = comparisons.begin();it!=comparisons.end();it++)
		{
			ofs<<*it << std::endl;
		}
		comparisons.clear();
	}
	ofs.close();
}
void main()
{
	_base = "D:\\GTL\\data\\";
	_cube_size_length=10000;
	for(int i=0;i<4;i++)
	{
		_cubeenvelope.setLowerBound(i,0);
		_cubeenvelope.setUpperBound(i,_cube_size_length);
	}

	test_xlist_rtree("oldenburg100000");
	test_xlist_rtree("oldenburg200000");
	test_xlist_rtree("oldenburg300000");
	test_xlist_rtree("oldenburg400000");
	test_xlist_rtree("oldenburg500000");
	test_xlist_rtree("oldenburg600000");
	test_xlist_rtree("oldenburg700000");
	test_xlist_rtree("oldenburg800000");
	test_xlist_rtree("oldenburg900000");
	test_xlist_rtree("oldenburg1000000");
}